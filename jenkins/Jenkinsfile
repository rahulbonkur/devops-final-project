pipeline {
  agent any

  parameters {
    choice(
      name: 'WHAT_TO_DEPLOY',
      choices: ['all', 'recipe', 'chatbot', 'destroy'],
      description: 'Select what you want to deploy'
    )
  }

  environment {
    AWS_REGION        = 'ap-south-1'
    CODEBUILD_PROJECT = 'ai-chatbot'
    ECS_CLUSTER       = 'ai-chatbot-cluster'
    ECS_SERVICE       = 'ai-chatbot-service'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        echo "‚úÖ Code checked out"
      }
    }

    stage('Terraform Destroy') {
      when {
        expression { params.WHAT_TO_DEPLOY == 'destroy' }
      }
      steps {
        dir('terraform') {
          sh '''
            terraform init -input=false
            terraform destroy -auto-approve
          '''
        }
      }
    }

stage('Terraform Apply') {
  when {
    expression { params.WHAT_TO_DEPLOY != 'destroy' }
  }
  steps {
    dir('terraform') {
      withCredentials([
        string(credentialsId: 'groq-api-key', variable: 'GROQ_API_KEY')
      ]) {
        sh '''
          terraform init -input=false
          terraform apply -auto-approve \
            -var="groq_api_key=$GROQ_API_KEY"
        '''
      }
    }
  }
}

    stage('Build AI Chatbot (CodeBuild)') {
      when {
        expression { params.WHAT_TO_DEPLOY == 'all' || params.WHAT_TO_DEPLOY == 'chatbot' }
      }
      steps {
        script {
          echo "üöÄ Starting CodeBuild..."

          def buildId = sh(
            script: """
              aws codebuild start-build \
                --project-name ${CODEBUILD_PROJECT} \
                --region ${AWS_REGION} \
                --query 'build.id' \
                --output text
            """,
            returnStdout: true
          ).trim()

          echo "üß± CodeBuild ID: ${buildId}"

          timeout(time: 20, unit: 'MINUTES') {
            waitUntil {
              def status = sh(
                script: """
                  aws codebuild batch-get-builds \
                    --ids ${buildId} \
                    --region ${AWS_REGION} \
                    --query 'builds[0].buildStatus' \
                    --output text
                """,
                returnStdout: true
              ).trim()

              echo "üîÑ CodeBuild status: ${status}"

              if (status == 'SUCCEEDED') return true
              if (status in ['FAILED','STOPPED','FAULT']) {
                error "‚ùå CodeBuild failed: ${status}"
              }
              sleep 15
              return false
            }
          }
        }
      }
    }

    stage('Deploy AI Chatbot to ECS') {
      when {
        expression { params.WHAT_TO_DEPLOY == 'all' || params.WHAT_TO_DEPLOY == 'chatbot' }
      }
      steps {
        sh '''
          echo "üöÄ Deploying AI Chatbot to ECS"
          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service ${ECS_SERVICE} \
            --force-new-deployment \
            --region ${AWS_REGION}
        '''
      }
    }

    stage('Deploy Recipe App (Ansible)') {
      when {
        expression { params.WHAT_TO_DEPLOY == 'all' || params.WHAT_TO_DEPLOY == 'recipe' }
      }
      steps {
        dir('ansible') {
          sh '''
            ansible-playbook \
              -i inventory/hosts \
              playbooks/deploy-recipe-app.yml
          '''
        }
      }
    }
  }

  post {
    success {
      echo "‚úÖ PIPELINE SUCCESS ‚Äì ${params.WHAT_TO_DEPLOY}"
    }
    failure {
      echo "‚ùå PIPELINE FAILED ‚Äì CHECK LOGS"
    }
  }
}
